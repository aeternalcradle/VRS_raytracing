// Progressive bilateral filter with fixed 5x5 kernel and pass-dependent stride
// Each pass uses a stride S = _Stride (e.g., 1,2,4,...) while kernel size stays 5x5
// Inputs: _InputColor (raw), _Normal, _BaseColor
// Output: _DenoisedColor

#pragma kernel CSMain

RWTexture2D<float4> _DenoisedColor;
Texture2D _InputColor;
SamplerState sampler_InputColor;
Texture2D _Normal;
SamplerState sampler_Normal;
Texture2D _BaseColor;
SamplerState sampler_BaseColor;
float2 _TexelSize; // 1/width, 1/height

// pass-dependent sampling stride (e.g., 1, 2, 4 = 2^i)
int _Stride;              // >= 1

// bilateral params
float _SigmaSpatial;      // spatial sigma in pixel units (applied before stride scaling)
float _SigmaColor;        // guided by base color
float _SigmaNormal;       // in cos-difference space
float _HighpassStrength;  // 0..1, amount of high-pass added back

// optional: whether to scale spatial sigma by stride to maintain shape over larger steps
int _ScaleSigmaWithStride; // 0 or 1

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	uint2 pix = id.xy;
	float2 uv = (pix + 0.5f) * _TexelSize;

	float4 center = _InputColor.SampleLevel(sampler_InputColor, uv, 0);
	float3 cCenter = center.rgb;
	float  aCenter = center.a;
	float3 nCenter = normalize(_Normal.SampleLevel(sampler_Normal, uv, 0).xyz);
	float3 gCenter = _BaseColor.SampleLevel(sampler_BaseColor, uv, 0).rgb;

	// fixed 5x5 kernel with stride S
	int S = max(_Stride, 1);
	float sigmaSpatial = _SigmaSpatial * ( (_ScaleSigmaWithStride != 0) ? (float)S : 1.0f );

	float wsum = 0;
	float3 lowpass = 0;

	[unroll]
	for (int dy = -2; dy <= 2; ++dy)
	{
		[unroll]
		for (int dx = -2; dx <= 2; ++dx)
		{
			float2 uvn = uv + float2(dx * S, dy * S) * _TexelSize;
			float3 c = _InputColor.SampleLevel(sampler_InputColor, uvn, 0).rgb;
			float3 n = normalize(_Normal.SampleLevel(sampler_Normal, uvn, 0).xyz);
			float3 g = _BaseColor.SampleLevel(sampler_BaseColor, uvn, 0).rgb;

			float ds2 = (dx*dx + dy*dy);
			float wSpatial = exp(-ds2 / (2.0f * sigmaSpatial * sigmaSpatial));
			float dc = length(g - gCenter);
			float wColor = exp(-(dc*dc) / (2.0f * _SigmaColor * _SigmaColor));
			float cosTheta = saturate(dot(n, nCenter));
			float dn = 1.0f - cosTheta;
			float wNormal = exp(-(dn*dn) / (2.0f * _SigmaNormal * _SigmaNormal));

			float w = wSpatial * wColor * wNormal;
			lowpass += c * w;
			wsum += w;
		}
	}
	lowpass /= max(wsum, 1e-6f);

	float3 highpass = cCenter - lowpass;
	float3 outColor = lowpass + _HighpassStrength * highpass;
	_DenoisedColor[pix] = float4(outColor, aCenter);
} 