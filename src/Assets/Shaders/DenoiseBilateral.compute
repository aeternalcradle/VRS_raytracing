// High-pass bilateral filter for space denoising
// Inputs: _InputColor (raw), _Normal, _BaseColor
// Output: _DenoisedColor

#pragma kernel CSMain

RWTexture2D<float4> _DenoisedColor;
Texture2D _InputColor;
SamplerState sampler_InputColor;
Texture2D _Normal;
SamplerState sampler_Normal;
Texture2D _BaseColor;
SamplerState sampler_BaseColor;
float2 _TexelSize; // 1/width, 1/height

// bilateral params
static const int RADIUS = 2; // 5x5 window
float _SigmaSpatial;   // e.g., 1.0
float _SigmaColor;     // e.g., 0.2 (guide by base color)
float _SigmaNormal;    // e.g., cos threshold equivalent ~ 0.1
float _HighpassStrength; // 0..1, amount of high-pass added back

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	uint2 pix = id.xy;
	float2 uv = (pix + 0.5f) * _TexelSize;

	float4 center = _InputColor.SampleLevel(sampler_InputColor, uv, 0);
	float3 cCenter = center.rgb;
	float  aCenter = center.a;
	float3 nCenter = normalize(_Normal.SampleLevel(sampler_Normal, uv, 0).xyz);
	float3 gCenter = _BaseColor.SampleLevel(sampler_BaseColor, uv, 0).rgb;

	float wsum = 0;
	float3 lowpass = 0;

	[unroll]
	for (int dy = -RADIUS; dy <= RADIUS; ++dy)
	{
		[unroll]
		for (int dx = -RADIUS; dx <= RADIUS; ++dx)
		{
			float2 uvn = uv + float2(dx, dy) * _TexelSize;
			float3 c = _InputColor.SampleLevel(sampler_InputColor, uvn, 0).rgb;
			float3 n = normalize(_Normal.SampleLevel(sampler_Normal, uvn, 0).xyz);
			float3 g = _BaseColor.SampleLevel(sampler_BaseColor, uvn, 0).rgb;

			float ds2 = (dx*dx + dy*dy);
			float wSpatial = exp(-ds2 / (2.0f * _SigmaSpatial * _SigmaSpatial));
			float dc = length(g - gCenter);
			float wColor = exp(-(dc*dc) / (2.0f * _SigmaColor * _SigmaColor));
			float cosTheta = saturate(dot(n, nCenter));
			float dn = 1.0f - cosTheta;
			float wNormal = exp(-(dn*dn) / (2.0f * _SigmaNormal * _SigmaNormal));

			float w = wSpatial * wColor * wNormal;
			lowpass += c * w;
			wsum += w;
		} 
	}
	lowpass /= max(wsum, 1e-6f);

	float3 highpass = cCenter - lowpass;
	float3 outColor = lowpass + _HighpassStrength * highpass;
	_DenoisedColor[pix] = float4(outColor, aCenter);
} 