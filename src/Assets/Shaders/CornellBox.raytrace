#pragma max_recursion_depth 11

#include "./Common.hlsl"
#include "./PRNG.hlsl"

#define MAX_DEPTH (10)
#define NUM_OF_SAMPLES (1)

RWTexture2D<float4> _OutputTarget;
float4 _OutputTargetSize;
int _FrameIndex;

// split outputs
RWTexture2D<float4> _DirectTarget;
RWTexture2D<float4> _IndirectTarget;

// G-buffer outputs for filtering
RWTexture2D<float4> _NormalTarget;
RWTexture2D<float4> _BaseColorTarget;

[shader("raygeneration")]
void CornellBoxGenShader()
{
  const uint2 dispatchIdx = DispatchRaysIndex().xy;
  const uint PRNGIndex = dispatchIdx.y * (int)_OutputTargetSize.x + dispatchIdx.x;
  uint4 PRNGStates = _PRNGStates[PRNGIndex];

  float4 finalColor = float4(0, 0, 0, 0);
  float hitT = -1.0f;
  float3 rayOrigin = 0;
  float3 rayDirection = 0;
  float3 curNormalWS = 0;
  float3 curBaseColor = 0;
  float3 directColor = 0;
  float3 indirectColor = 0;
  {
    float3 origin;
    float3 direction;
    float2 apertureOffset = GetRandomInUnitDisk(PRNGStates);
    float2 offset = float2(GetRandomValue(PRNGStates), GetRandomValue(PRNGStates));
    //这里用了taa的办法，每一个像素不再是中心点发射光线，而是类似于msaa的多个覆盖，解决锯齿问题，但是后续引入的重投影发生冲突，暂时弃用。
    //GenerateFocusCameraRayWithOffset(origin, direction, apertureOffset, offset);
    GenerateCameraRay(origin,direction);

    RayDesc rayDescriptor;
    rayDescriptor.Origin = origin;
    rayDescriptor.Direction = direction;
    rayDescriptor.TMin = 1e-5f;
    rayDescriptor.TMax = _CameraFarDistance;

    RayIntersection rayIntersection;
    rayIntersection.remainingDepth = MAX_DEPTH - 1;
    rayIntersection.PRNGStates = PRNGStates;
    rayIntersection.color = float4(0.0f, 0.0f, 0.0f, 0.0f);
    rayIntersection.hitT = -1.0f;
    rayIntersection.normalWS = 0;
    rayIntersection.baseColor = 0;
    rayIntersection.emittedPrimary = 0;

    TraceRay(_AccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);
    PRNGStates = rayIntersection.PRNGStates;
    directColor = rayIntersection.emittedPrimary;
    indirectColor = max(0.0f.xxx, rayIntersection.color.rgb - directColor);
    finalColor += float4(directColor + indirectColor, 0);
    hitT = rayIntersection.hitT;
    rayOrigin = origin;
    rayDirection = direction;
    curNormalWS = normalize(rayIntersection.normalWS);
    curBaseColor = rayIntersection.baseColor;
    //finalColor = float4(
    //  clamp(0.0f, 1.0f, rayIntersection.color.r),
    //  clamp(0.0f, 1.0f, rayIntersection.color.g),
    //  clamp(0.0f, 1.0f, rayIntersection.color.b),
    //  clamp(0.0f, 1.0f, rayIntersection.color.a));
  }
  float4 directOut = float4(directColor, 1.0f);
  float4 indirectOut = float4(indirectColor, 1.0f);
  // Optional preview tonemap
  finalColor = float4(sqrt(finalColor.r), sqrt(finalColor.g), sqrt(finalColor.b), finalColor.a);

  // write current normal (w=1 means valid when hit)
  float4 normalOut = (hitT > 0.0f) ? float4(curNormalWS, 1.0f) : float4(0, 0, 0, 0);
  _NormalTarget[dispatchIdx] = normalOut;
  // write current base color (w=1 means valid when hit)
  float4 baseColorOut = (hitT > 0.0f) ? float4(curBaseColor, 1.0f) : float4(0, 0, 0, 0);
  _BaseColorTarget[dispatchIdx] = baseColorOut;

  _PRNGStates[PRNGIndex] = PRNGStates;
  // write split outputs
  _DirectTarget[dispatchIdx] = (hitT > 0.0f) ? directOut : float4(0,0,0,0);
  _IndirectTarget[dispatchIdx] = (hitT > 0.0f) ? indirectOut : float4(0,0,0,0);

  finalColor.a = max(0.0f, hitT);
  _OutputTarget[dispatchIdx] = finalColor;
}

[shader("miss")]
void MissShader(inout RayIntersection rayIntersection : SV_RayPayload)
{
  rayIntersection.color = float4(0.0f, 0.0f, 0.0f, 1.0f);
  rayIntersection.hitT = -1.0f;
}
